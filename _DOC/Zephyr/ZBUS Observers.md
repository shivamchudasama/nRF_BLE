> Answers are generated by Nordic Semiconductor's AI chatbot and may not be fully accurate. The service is provided as is, without any warranties regarding completeness, reliability or accuracy. User discretion is advised. Nordic Semiconductor disclaim all warranties and shall not be liable for any damages arising from the use of its AI systems.


---

## Please give me a basic example of zbus setup where one thread is the publisher and another one is the observer.
Below is a minimal pattern taken from the zbus documentation showing one thread publishing to a channel and another thread observing it as a subscriber. I’ll keep it close to the reference code and trim it to the essentials. [Zbus usage]

```c
#include <zephyr/kernel.h>
#include <zephyr/zbus/zbus.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(app, LOG_LEVEL_INF);

/* 1. Define the message type carried on the channel */
struct acc_msg {
	int x;
	int y;
	int z;
};

/* 2. Forward-declare the subscriber so we can list it as an observer */
ZBUS_SUBSCRIBER_DEFINE(my_subscriber, 4);

/* 3. Define the channel and list the subscriber as an observer */
ZBUS_CHAN_DEFINE(acc_chan,                  /* Name */
		 struct acc_msg,              /* Message type */
		 NULL,                        /* Validator */
		 NULL,                        /* User data */
		 ZBUS_OBSERVERS(my_subscriber),/* Observers */
		 ZBUS_MSG_INIT(.x = 0, .y = 0, .z = 0)); /* Initial value */

/* 4. Observer thread: waits for notifications and reads the message */
static void subscriber_task(void)
{
	const struct zbus_channel *chan;

	while (!zbus_sub_wait(&my_subscriber, &chan, K_FOREVER)) {
		if (&acc_chan == chan) {
			struct acc_msg acc;

			/* Read the latest message from the channel */
			zbus_chan_read(&acc_chan, &acc, K_NO_WAIT);

			LOG_INF("Observer got: x=%d, y=%d, z=%d",
				acc.x, acc.y, acc.z);
		}
	}
}

K_THREAD_DEFINE(subscriber_task_id, 512,
		subscriber_task, NULL, NULL, NULL,
		3, 0, 0);

/* 5. Publisher thread: periodically publishes messages to the channel */
static void publisher_task(void)
{
	struct acc_msg acc = { .x = 0, .y = 0, .z = 0 };

	while (1) {
		acc.x++;
		acc.y++;
		acc.z++;

		/* Publish to the channel (1 second timeout example) */
		int err = zbus_chan_pub(&acc_chan, &acc, K_SECONDS(1));
		if (err) {
			LOG_ERR("zbus_chan_pub failed: %d", err);
		}

		k_sleep(K_SECONDS(1));
	}
}

K_THREAD_DEFINE(publisher_task_id, 512,
		publisher_task, NULL, NULL, NULL,
		2, 0, 0);
```

### Key points

ZBUS_CHAN_DEFINE creates the channel and ties it to the my_subscriber observer. [Zbus usage]
The publisher thread calls zbus_chan_pub(&acc_chan, &acc, timeout) to send messages. [Publishing to a channel]
The observer thread uses zbus_sub_wait() to wait for channel activity, then zbus_chan_read() to get the message. [Zbus usage]

### Answer based on the following sources:

Publishing to a channel
docs.nordicsemi.com/bundle
Usage

Usage
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle


---

## Here, the subscriber is waiting forever for the publisher to publish something. I don't want this kind of blocking functionality. Is there any other way? Additionally, while defining the ZBUS, we need to tell the subscriber and the publisher. What if I might want to decide these things at runtime? Can I assign them at runtime?
You have two separate needs:

Non‑blocking behavior for the observer
Deciding who observes what at runtime
Both are supported by zbus.

1. Non‑blocking observer (no K_FOREVER wait)
The blocking behavior comes from using zbus_sub_wait(..., K_FOREVER). You can:

Use a listener instead of a subscriber. A listener is called synchronously in the publisher’s context and does not block on its own thread. [Zbus concepts]

```c
/* Channel definition with a listener as observer */
ZBUS_CHAN_DEFINE(acc_chan,
                 struct acc_msg,
                 NULL,
                 NULL,
                 ZBUS_OBSERVERS(my_listener),
                 ZBUS_MSG_INIT(.x = 0, .y = 0, .z = 0));

/* Listener callback: runs in publisher's context, no blocking wait */
void listener_callback_example(const struct zbus_channel *chan)
{
    const struct acc_msg *acc;

    if (&acc_chan == chan) {
        acc = zbus_chan_const_msg(chan);
        LOG_DBG("From listener: x=%d, y=%d, z=%d", acc->x, acc->y, acc->z);
    }
}

ZBUS_LISTENER_DEFINE(my_listener, listener_callback_example);
```
Here, the observer never calls a blocking wait; it is invoked automatically when the publisher calls zbus_chan_pub() or zbus_chan_notify(). [Zbus usage]

If you still want a subscriber but avoid blocking, you can use a finite timeout (e.g. K_NO_WAIT or K_MSEC(...)) instead of K_FOREVER in zbus_sub_wait() and handle the timeout yourself. The docs show the blocking form but do not forbid non‑blocking/timeout usage; however, they do not give a concrete non‑blocking example. [Zbus usage]

2. Deciding observers at runtime
Yes, you can assign which observers are attached to which channels at runtime using runtime observer registration. [Runtime observer registration]

Enable runtime observers in Kconfig:

CONFIG_ZBUS_RUNTIME_OBSERVERS
And one of:
CONFIG_ZBUS_RUNTIME_OBSERVERS_NODE_ALLOC_DYNAMIC, or
CONFIG_ZBUS_RUNTIME_OBSERVERS_NODE_ALLOC_STATIC, or
CONFIG_ZBUS_RUNTIME_OBSERVERS_NODE_ALLOC_NONE (for user‑provided nodes). [Runtime observer registration; Zbus configuration]
At runtime, add/remove observers:

```c
ZBUS_LISTENER_DEFINE(my_listener, callback);

void thread_entry(void)
{
    /* Add observer to channel at runtime */
    zbus_chan_add_obs(&chan1, &my_listener, K_NO_WAIT);

    /* Later, remove it again */
    zbus_chan_rm_obs(&chan1, &my_listener, K_NO_WAIT);
}
```
[Runtime observer registration; zbus_chan_add_obs; zbus_chan_rm_obs]

This lets you:

Define channels without hard‑wiring all observers at build time.
Dynamically “subscribe” or “unsubscribe” listeners/subscribers to channels depending on runtime conditions.
If you need full manual control of the node memory, you can use zbus_chan_add_obs_with_node() with your own zbus_observer_node, but that’s only when CONFIG_ZBUS_RUNTIME_OBSERVERS_NODE_ALLOC_NONE is selected. [zbus_chan_add_obs_with_node]


### Summary

To avoid blocking: use listeners (or async listeners) instead of thread‑based subscribers, or use timeouts instead of K_FOREVER.
To decide publisher/observer relationships at runtime: enable runtime observers and use zbus_chan_add_obs() / zbus_chan_rm_obs() to attach/detach observers dynamically.

### Answer based on the following sources:

Configuration Options
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle

Usage
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle

Concepts
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle

Runtime observer registration
docs.nordicsemi.com/bundle
Usage


---

## First, we've seen the subscriber; now, there is another type of observer - the listener. What are the different kinds of observers available with ZBUS?
Zbus defines four observer types. All of them are represented by the zbus_observer_type enum: [zbus_observer_type; Zbus concepts]

Listener (ZBUS_OBSERVER_LISTENER_TYPE)

Callback executed synchronously in the publisher’s context whenever an observed channel is published or notified. [Zbus concepts; zbus_observer]
Accesses the channel (often via zbus_chan_const_msg() for direct, read‑only access). [Advanced channel control – listeners]
Async listener (ZBUS_OBSERVER_ASYNC_LISTENER_TYPE)

Also a callback, but executed asynchronously in a work queue context (system work queue by default) instead of the publisher’s thread. [Advanced channel control – async listeners; zbus_observer_type]
Receives a copy of the message via the message pointer argument. [Advanced channel control – async listeners]
Subscriber (ZBUS_OBSERVER_SUBSCRIBER_TYPE)

Thread‑based observer with an internal message queue. [Zbus concepts; zbus_observer]
Receives only a reference to the channel when notified; it must call zbus_chan_read() (or similar) to read the message from the channel. [Zbus concepts; Usage example]
Message subscriber (ZBUS_OBSERVER_MSG_SUBSCRIBER_TYPE)

Also thread‑based, but uses an internal FIFO. [Zbus concepts; zbus_observer]
Receives a copy of the message for each notification (e.g., via zbus_sub_wait_msg() in the examples). [Zbus concepts; Usage example]
All four are just different ways for code (threads or callbacks) to observe zbus channels, with different threading and message‑delivery semantics.


### Answer based on the following sources:

Advanced channel control
docs.nordicsemi.com/bundle
Usage

Usage
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle

Concepts
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle


---

## Please explain each of them with an example. Additionally, what are the nuances of them, and when to use which observer type?
Zbus has four observer types. Below is what each one does, a small example (taken/condensed from the docs), and when to use which. All examples assume you already have a channel defined and configured with the relevant observer(s).

1. Listener (ZBUS_OBSERVER_LISTENER_TYPE)
What it is

A callback that runs synchronously in the publisher’s thread context whenever an observed channel is published or notified. [Concepts; zbus_observer]
It gets a const struct zbus_channel *chan and can read the message directly with zbus_chan_const_msg(). [Advanced channel control – listeners]
Example

From the zbus usage docs (accelerometer example): [Usage]

```c
struct acc_msg {
        int x;
        int y;
        int z;
};

ZBUS_CHAN_DEFINE(acc_chan,
         struct acc_msg,
         NULL,
         NULL,
         ZBUS_OBSERVERS(my_listener),
         ZBUS_MSG_INIT(.x = 0, .y = 0, .z = 0)
);

/* Listener callback: runs in publisher's context */
void listener_callback_example(const struct zbus_channel *chan)
{
        const struct acc_msg *acc;

        if (&acc_chan == chan) {
                acc = zbus_chan_const_msg(chan);  /* direct, read-only access */
                LOG_DBG("From listener -> Acc x=%d, y=%d, z=%d",
                        acc->x, acc->y, acc->z);
        }
}

ZBUS_LISTENER_DEFINE(my_listener, listener_callback_example);
```
Nuances / when to use

Runs inline with the publisher, so:
Very low latency.
Must be fast and non‑blocking (treat like an ISR). [Limitations – delivery guarantees]
Good for:
Simple, quick reactions (toggle LED, update a flag, post work to a queue).
Situations where you don’t want a dedicated thread for the observer.
Not good for:
Long or blocking operations (network I/O, file I/O, long computations).
2. Async listener (ZBUS_OBSERVER_ASYNC_LISTENER_TYPE)
What it is

Also a callback, but executed asynchronously in a work queue context (system work queue by default), not in the publisher’s thread. [Advanced channel control – async listeners; zbus_observer_type]
Receives:
const struct zbus_channel *chan
const void *message – a copy of the message; freed right after the callback returns. [Advanced channel control – async listeners]
Example

From the async listener section: [Advanced channel control – async listeners]

```c
static void async_listener_callback(const struct zbus_channel *chan,
                                    const void *message)
{
        if (chan != &chan_event) {
                LOG_ERR("Unexpected channel");
                return;
        }

        const struct msg_event *msg = message;

        LOG_INF("From async listener -> Evt=%d | %s",
                msg->type,
                k_thread_name_get(k_current_get()));
}
```
(Definition of the async listener and channel is shown in the async listener sample referenced by the docs.)

Nuances / when to use

Decouples publisher latency from observer work:
Publisher only enqueues work; heavy processing happens in the work queue.
Still must not block excessively, because it runs in a work queue, but it can do more work than a plain listener.
Good for:
Medium‑weight processing that you don’t want to run in the publisher’s thread.
Offloading from a listener: listener can just schedule an async listener or work item. [Limitations – delivery guarantees]
Message is a copy, so:
Safe from later channel overwrites.
But you pay extra memory and copy cost.
3. Subscriber (ZBUS_OBSERVER_SUBSCRIBER_TYPE)
What it is

A thread‑based observer with an internal message queue. [Concepts; zbus_observer]
On notification, zbus enqueues a reference to the channel; the subscriber thread later calls zbus_sub_wait() to get the channel pointer and then reads the message from the channel (e.g. zbus_chan_read()). [Concepts; Usage]
Example

From the zbus usage example: [Usage]

```c
ZBUS_SUBSCRIBER_DEFINE(my_subscriber, 4);

void subscriber_task(void)
{
        const struct zbus_channel *chan;

        while (!zbus_sub_wait(&my_subscriber, &chan, K_FOREVER)) {
                struct acc_msg acc = {0};

                if (&acc_chan == chan) {
                        /* Indirect message access */
                        zbus_chan_read(&acc_chan, &acc, K_NO_WAIT);
                        LOG_DBG("From subscriber -> Acc x=%d, y=%d, z=%d",
                                acc.x, acc.y, acc.z);
                }
        }
}

K_THREAD_DEFINE(subscriber_task_id, 512,
                subscriber_task, NULL, NULL, NULL,
                3, 0, 0);
```
Nuances / when to use

Asynchronous: work happens in the subscriber’s own thread.
Receives only a channel reference, not a copy:
If the channel is published twice before the subscriber reads it, the second write overwrites the first; subscriber sees only the latest data, even though it got two notifications. [Limitations – delivery guarantees]
Internal queue holds notifications, not message copies.
Good for:
Modules that already have their own thread and may block while handling messages (e.g., sending AT commands, waiting on I/O). [Asset Tracker – message subscribers vs listeners]
Cases where losing intermediate values is acceptable (you only care about the latest state).
You can adjust the internal queue size via Kconfig in some samples (e.g. MQTT sample’s CONFIG_MQTT_SAMPLE_SAMPLER_MESSAGE_QUEUE_SIZE). [MQTT sample – subscribers]
4. Message subscriber (ZBUS_OBSERVER_MSG_SUBSCRIBER_TYPE)
What it is

Also thread‑based, but uses an internal FIFO that stores copies of messages. [Concepts; zbus_observer]
The subscriber thread uses zbus_sub_wait_msg() to get both the channel and a message copy. [Usage]
Example

From the zbus usage example: [Usage]

```c
ZBUS_MSG_SUBSCRIBER_DEFINE(my_msg_subscriber);

static void msg_subscriber_task(void *ptr1, void *ptr2, void *ptr3)
{
        ARG_UNUSED(ptr1);
        ARG_UNUSED(ptr2);
        ARG_UNUSED(ptr3);

        const struct zbus_channel *chan;
        struct acc_msg acc = {0};

        while (!zbus_sub_wait_msg(&my_msg_subscriber, &chan, &acc, K_FOREVER)) {
                if (&acc_chan == chan) {
                        LOG_INF("From msg subscriber -> Acc x=%d, y=%d, z=%d",
                                acc.x, acc.y, acc.z);
                }
        }
}

K_THREAD_DEFINE(msg_subscriber_task_id, 1024,
                msg_subscriber_task, NULL, NULL, NULL,
                3, 0, 0);
```
Nuances / when to use

Each notification carries a message copy, so:
You don’t lose intermediate values: every published message can be processed, as long as buffer resources are sufficient. [Limitations – delivery guarantees]
Higher memory and copy overhead.
Uses net_buf under the hood; you must size:
CONFIG_ZBUS_MSG_SUBSCRIBER_NET_BUF_POOL_SIZE
CONFIG_HEAP_MEM_POOL_ADD_SIZE_ZBUS and optionally isolation options. [Limitations – delivery guarantees]
Good for:
Consumers that must see every message (e.g., logging, buffering sensor samples).
More complex pipelines where message history matters.
When to choose which (summary)
Based on the docs’ guidance and examples: [Concepts; Limitations; Asset Tracker observers]

Listener
Use when:
You need immediate, low‑latency reaction.
Handler is very quick and non‑blocking.
You don’t want a dedicated thread.
Async listener
Use when:
You want to offload work from the publisher but still use a callback style.
Work is heavier than a listener should do, but still suitable for a work queue.
You’re okay with message copies and work‑queue scheduling.
Subscriber
Use when:
The module has its own thread and may block while handling messages.
It’s acceptable to only see the latest state if multiple updates happen quickly.
Message subscriber
Use when:
You need to process every message (no data loss).
You can afford extra memory and copy overhead.
A dedicated thread per subscriber is acceptable.
If you describe your concrete use case (e.g., “sensor data at X Hz, sometimes heavy processing, must / must not lose samples”), I can help map it to the most suitable observer type(s) using these patterns.


### Answer based on the following sources:

Modules
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle

Limitations
docs.nordicsemi.com/bundle
Concepts

Advanced channel control
docs.nordicsemi.com/bundle
Usage


Show all (6)


---

## Unlike Message Subscriber, is the copy happens with Subscriber type of observer?
No – for the plain Subscriber type, zbus does not copy the message to the subscriber. It only delivers a reference to the channel, and the subscriber must then read the current message from the channel itself.

From the concepts section:

A Subscriber “relies internally on a message queue where the event dispatcher puts a changed channel’s reference every time an observed channel is published or notified. Note this kind of observer does not receive the message itself. It should read the message from the channel after receiving the notification.” [Zbus concepts]
This is why the subscriber example does:

```c
while (!zbus_sub_wait(&my_subscriber, &chan, K_FOREVER)) {
    struct acc_msg acc = {0};

    if (&acc_chan == chan) {
        // Indirect message access
        zbus_chan_read(&acc_chan, &acc, K_NO_WAIT);
    }
}
```
The Message Subscriber, in contrast, “relies internally on a FIFO where the event dispatcher puts a copy of the message every time an observed channel is published or notified,” and the API zbus_sub_wait_msg() explicitly returns that copy. [Zbus concepts; zbus_sub_wait_msg]

So:

Subscriber: no automatic message copy; only channel reference is queued.
Message Subscriber: a copy of the message is queued and delivered.

### Answer based on the following sources:

Concepts
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle


---

## So is it safe to say that Subscriber is comparatively faster then Message Subscriber?
Yes, with an important nuance.

From the docs:

Subscriber: only a reference to the channel is queued; the subscriber then calls zbus_chan_read() to copy the current message from the channel. No per‑notification message buffer is allocated by zbus. [Zbus concepts]
Message subscriber: the VDED “puts a copy of the message every time an observed channel is published or notified” into a FIFO, using net_buf and heap/pool resources. [Zbus concepts; Limitations – delivery guarantees]
Because message subscribers require extra copying and buffer management, they inherently have more overhead than plain subscribers. So it is reasonable to say that, for the same message size and conditions, a Subscriber is typically lighter and faster than a Message Subscriber.

However, the docs do not provide a direct benchmark comparison, so this is based on the described mechanisms (no copy vs copy), not on measured numbers.


### Answer based on the following sources:

Limitations
docs.nordicsemi.com/bundle
Concepts

Concepts
docs.nordicsemi.com/bundle
docs.nordicsemi.com/bundle


---

## So, unlike the Listener, the Subscriber copies the message after checking the notification. Is this correct?
Mostly correct, but with an important detail:

Listener:
Runs in the publisher’s context and typically uses zbus_chan_const_msg(chan) to get a direct, read‑only pointer to the channel’s message. No copy is made; it just reads the already‑locked channel buffer. [Listeners message access; zbus_chan_const_msg]

Subscriber:
When notified, it only receives a reference to the channel in its queue; it “does not receive the message itself. It should read the message from the channel after receiving the notification.” [Concepts]
In practice, the subscriber usually calls zbus_chan_read(&acc_chan, &acc, ...), which copies the current channel message into a local variable. [Usage example]

So:

Listener: no copy, direct const access to the channel’s message.
Subscriber: gets a channel reference, then typically copies the message out with zbus_chan_read().
